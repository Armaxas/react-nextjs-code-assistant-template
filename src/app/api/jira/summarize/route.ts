export const dynamic = "force-dynamic";

import { auth } from "@/auth";
import { WatsonxLLM } from "@langchain/community/llms/ibm";
import { PromptTemplate } from "@langchain/core/prompts";
import { getServerDefaultModel } from "@/lib/models-config";
import { type JiraIssue, formatJiraIssuesForAI } from "@/services/jira-service";

export async function POST(req: Request) {
  try {
    const session = await auth();

    if (!session?.user?.id) {
      return Response.json(
        {
          status: "error",
          message: "Unauthorized access",
        },
        { status: 401 }
      );
    }

    const requestData = await req.json();
    const { issues, type = "multiple", selectedModel } = requestData;

    // Determine which model to use
    const modelToUse = selectedModel || getServerDefaultModel();

    if (!issues || (Array.isArray(issues) && issues.length === 0)) {
      return Response.json(
        {
          status: "error",
          message: "JIRA issues are required for summarization",
        },
        { status: 400 }
      );
    }

    // Ensure we have an array of issues for consistent processing
    const issueArray: JiraIssue[] = Array.isArray(issues) ? issues : [issues];

    // Format issues for AI analysis
    const issuesContext = formatJiraIssuesForAI(issueArray);

    // Create prompt template based on analysis type and number of issues
    let promptTemplate = "";

    if (type === "single" || issueArray.length === 1) {
      promptTemplate = `Analyze this JIRA issue from a developer's perspective. Be concise and practical.

**What it does:** Brief explanation of the goal and functionality.

**Dev work required:**
• Type: Bug fix, feature, refactor, etc.
• Areas: Which components/systems need changes
• Effort: Quick estimate (small/medium/large)

**Implementation notes:** Key technical considerations or gotchas.

**Why it matters:** Business impact and priority context.

Target: 30-second read for sprint planning.

JIRA ISSUE:
{content}`;
    } else {
      promptTemplate = `Analyze these related JIRA issues. Focus on connections and combined impact.

**Big picture:** What's the overall goal these issues achieve together?

**Issue relationships:**
• Dependencies: Which issues block others?
• Grouping: Are they part of the same feature/epic/theme?
• Sequence: Recommended development order

**Technical coordination:**
• Shared components/systems involved
• Integration points between issues
• Potential conflicts or overlaps

**Sprint planning:**
• Can any run in parallel?
• Critical path items
• Resource allocation suggestions

**Combined value:** What's delivered when all are complete?

Target: Quick project coordination insights.

JIRA ISSUES:
{content}`;
    }

    // Create prompt template
    const prompt = PromptTemplate.fromTemplate(promptTemplate);

    // Format the prompt with the content
    const formattedPrompt = await prompt.format({
      content: issuesContext,
    });

    try {
      // Initialize WatsonX LLM with the selected model
      const model = new WatsonxLLM({
        model: modelToUse, // Use selected model or default
        watsonxAIAuthType: "iam",
        watsonxAIApikey: process.env.WATSONX_API_KEY || "",
        serviceUrl: "https://us-south.ml.cloud.ibm.com",
        projectId: process.env.WATSONX_PROJECT_ID || "",
        version: "2023-05-29",
        maxNewTokens: issueArray.length === 1 ? 500 : 600, // Reduced tokens for more concise responses
        minNewTokens: 100,
        temperature: 0.3, // Lower temperature for more focused analysis
        topP: 0.9,
      });

      // Generate summary using the model
      let summary = await model.invoke(formattedPrompt);
      console.log(
        `Generated JIRA ${type} analysis for ${issueArray.length} issue(s):`,
        summary
      );

      if (!summary || summary.trim() === "") {
        console.error("Empty summary generated by the model");
        return Response.json(
          {
            status: "error",
            message: "Generated summary was empty",
          },
          { status: 500 }
        );
      }

      // Clean up the summary - trim whitespace and normalize newlines
      summary = summary.trim();

      return Response.json({
        status: "success",
        summary: summary,
        type: type,
        issuesAnalyzed: issueArray.length,
      });
    } catch (aiError) {
      console.error("WatsonX API request failed for JIRA analysis:", aiError);
      return Response.json(
        {
          status: "error",
          message: "AI service request failed",
          details: aiError instanceof Error ? aiError.message : "Unknown error",
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("JIRA summary generation error:", error);
    return Response.json(
      {
        status: "error",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
